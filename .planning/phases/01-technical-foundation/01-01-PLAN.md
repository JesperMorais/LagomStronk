---
phase: 01-technical-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - js/core/eventBus.js
  - js/core/storage.js
  - package.json
  - package-lock.json
autonomous: true

must_haves:
  truths:
    - "Event bus exists and can emit/subscribe to events"
    - "Storage abstraction can read/write data"
    - "idb-keyval dependency is installed"
  artifacts:
    - path: "js/core/eventBus.js"
      provides: "Event bus singleton with on/off/emit/once methods"
      exports: ["eventBus", "EVENTS"]
    - path: "js/core/storage.js"
      provides: "Storage abstraction layer"
      exports: ["storageGet", "storageSet", "storageDelete", "initializeStorage"]
  key_links:
    - from: "js/core/eventBus.js"
      to: "js/core/storage.js"
      via: "import for migration events"
      pattern: "import.*eventBus"
---

<objective>
Create the core infrastructure modules for Phase 1: event bus for decoupled communication and storage abstraction layer that can switch between localStorage and IndexedDB.

Purpose: These are the foundational building blocks that all other Phase 1 work depends on. The event bus enables future features (gamification, analytics) to subscribe to app events without coupling. The storage abstraction prepares for IndexedDB migration.

Output: Two core modules (eventBus.js, storage.js) and idb-keyval installed.
</objective>

<execution_context>
@/home/david/.claude/get-shit-done/workflows/execute-plan.md
@/home/david/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/phases/01-technical-foundation/01-CONTEXT.md
@.planning/phases/01-technical-foundation/01-RESEARCH.md
@js/data.js
@package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install idb-keyval and create event bus</name>
  <files>
    - package.json
    - package-lock.json
    - js/core/eventBus.js
  </files>
  <action>
1. Install idb-keyval:
   ```bash
   npm install idb-keyval
   ```

2. Create `js/core/` directory if it doesn't exist.

3. Create `js/core/eventBus.js` using native EventTarget pattern from research:
   - Create EventBus class using document.createComment as event target (invisible DOM node)
   - Implement methods: `on(type, listener)` returns unsubscribe function, `once(type, listener)`, `off(type, listener)`, `emit(type, detail)`
   - Export singleton `eventBus`
   - Export `EVENTS` constant object with event type strings:
     - WORKOUT_COMPLETED: 'workout:completed'
     - EXERCISE_ADDED: 'exercise:added'
     - STORAGE_WARNING: 'storage:warning'
     - STORAGE_CRITICAL: 'storage:critical'
     - MIGRATION_STARTED: 'migration:started'
     - MIGRATION_COMPLETE: 'migration:complete'
     - MIGRATION_FAILED: 'migration:failed'

Reference the Pattern 2 example in 01-RESEARCH.md for implementation.
  </action>
  <verify>
    - `npm ls idb-keyval` shows package installed
    - `js/core/eventBus.js` exists and exports eventBus and EVENTS
    - Quick manual test: import eventBus in browser console, call emit/on
  </verify>
  <done>
    - idb-keyval in package.json dependencies
    - eventBus.js exports working event bus singleton
    - EVENTS object contains all 7 event type constants
  </done>
</task>

<task type="auto">
  <name>Task 2: Create storage abstraction layer</name>
  <files>
    - js/core/storage.js
  </files>
  <action>
1. Create `js/core/storage.js` with dual-mode storage abstraction:

2. Import from idb-keyval: `get`, `set`, `del`, `keys`, `clear`

3. Define constants:
   - STORAGE_KEY = 'lagomstronk_data'
   - MIGRATION_FLAG_KEY = 'lagomstronk_migrated'
   - BACKUP_KEY = 'lagomstronk_backup'

4. Implement module-level state:
   - `let storageMode = 'localStorage'` (default until migration verified)

5. Implement async functions:

   `initializeStorage()`:
   - Check if MIGRATION_FLAG_KEY exists in IndexedDB (using idb-keyval get)
   - If migrated flag exists and is truthy, set storageMode = 'indexedDB'
   - Return storageMode

   `storageGet(key)`:
   - If storageMode === 'indexedDB': return await get(key)
   - Else: return JSON.parse(localStorage.getItem(key)) or null

   `storageSet(key, value)`:
   - If storageMode === 'indexedDB': await set(key, value)
   - Else: localStorage.setItem(key, JSON.stringify(value))

   `storageDelete(key)`:
   - If storageMode === 'indexedDB': await del(key)
   - Else: localStorage.removeItem(key)

   `isUsingIndexedDB()`:
   - Return storageMode === 'indexedDB'

   `enableIndexedDB()`:
   - Set storageMode = 'indexedDB' (for migration process to call)

6. Export all functions and constants (STORAGE_KEY, MIGRATION_FLAG_KEY, BACKUP_KEY).

Note: Do NOT modify js/data.js yet - that happens in Plan 02 after migration is ready.
  </action>
  <verify>
    - `js/core/storage.js` exists
    - File exports: storageGet, storageSet, storageDelete, initializeStorage, isUsingIndexedDB, enableIndexedDB, STORAGE_KEY, MIGRATION_FLAG_KEY, BACKUP_KEY
    - No syntax errors (attempt import in browser)
  </verify>
  <done>
    - storage.js provides async storage API
    - Default mode is localStorage (safe for existing app)
    - Storage can be switched to IndexedDB via enableIndexedDB()
  </done>
</task>

</tasks>

<verification>
After both tasks complete:
1. `npm ls idb-keyval` shows ^x.x.x installed
2. Both files exist in js/core/
3. No import/export errors when loading in browser
4. App still works (we haven't modified data.js yet, so no functional change)
</verification>

<success_criteria>
- idb-keyval dependency installed
- js/core/eventBus.js exports working event bus with EVENTS constants
- js/core/storage.js exports async storage abstraction with dual-mode support
- No breaking changes to existing app (data.js untouched)
</success_criteria>

<output>
After completion, create `.planning/phases/01-technical-foundation/01-01-SUMMARY.md`
</output>

---
phase: 01-technical-foundation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - js/data/migration.js
  - js/data.js
autonomous: true

must_haves:
  truths:
    - "Existing localStorage data migrates to IndexedDB without data loss"
    - "Migration verifies data integrity before marking complete"
    - "Migration emits events for started/complete/failed states"
    - "data.js uses async storage abstraction"
    - "App continues working with migrated data"
  artifacts:
    - path: "js/data/migration.js"
      provides: "Silent migration from localStorage to IndexedDB"
      exports: ["migrateToIndexedDB", "retryMigration"]
    - path: "js/data.js"
      provides: "Data operations using async storage"
      contains: "async function loadData"
  key_links:
    - from: "js/data/migration.js"
      to: "js/core/eventBus.js"
      via: "emits migration events"
      pattern: "eventBus\\.emit\\(EVENTS\\.MIGRATION"
    - from: "js/data/migration.js"
      to: "js/core/storage.js"
      via: "uses storage abstraction"
      pattern: "import.*storage"
    - from: "js/data.js"
      to: "js/core/storage.js"
      via: "uses storageGet/storageSet"
      pattern: "await storage(Get|Set)"
---

<objective>
Implement the localStorage to IndexedDB migration system and refactor data.js to use async storage.

Purpose: This is the core of FNDN-01 (storage abstraction with IndexedDB migration path). Migration runs silently on app load, verifies data integrity, keeps localStorage backup, and emits events for monitoring.

Output: Working migration system and async data layer.
</objective>

<execution_context>
@/home/david/.claude/get-shit-done/workflows/execute-plan.md
@/home/david/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/phases/01-technical-foundation/01-CONTEXT.md
@.planning/phases/01-technical-foundation/01-RESEARCH.md
@.planning/phases/01-technical-foundation/01-01-SUMMARY.md
@js/core/eventBus.js
@js/core/storage.js
@js/data.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create migration module</name>
  <files>
    - js/data/migration.js
  </files>
  <action>
1. Create `js/data/` directory if it doesn't exist.

2. Create `js/data/migration.js`:

3. Import dependencies:
   - `{ get, set }` from 'idb-keyval'
   - `{ eventBus, EVENTS }` from '../core/eventBus.js'
   - `{ STORAGE_KEY, MIGRATION_FLAG_KEY, BACKUP_KEY, enableIndexedDB }` from '../core/storage.js'

4. Implement `migrateToIndexedDB()`:
   ```
   async function migrateToIndexedDB() {
     // 1. Check if already migrated
     const migrated = await get(MIGRATION_FLAG_KEY);
     if (migrated) {
       return { success: true, skipped: true };
     }

     eventBus.emit(EVENTS.MIGRATION_STARTED);

     try {
       // 2. Read from localStorage
       const localStorageData = localStorage.getItem(STORAGE_KEY);
       if (!localStorageData) {
         // No data to migrate - mark as migrated anyway
         await set(MIGRATION_FLAG_KEY, { migratedAt: new Date().toISOString() });
         enableIndexedDB();
         eventBus.emit(EVENTS.MIGRATION_COMPLETE, { hadData: false });
         return { success: true, hadData: false };
       }

       const data = JSON.parse(localStorageData);

       // 3. Write to IndexedDB
       await set(STORAGE_KEY, data);

       // 4. Verify migration (critical - read back and compare)
       const verified = await get(STORAGE_KEY);
       if (!verified || JSON.stringify(verified) !== JSON.stringify(data)) {
         throw new Error('Migration verification failed');
       }

       // 5. Mark as migrated
       await set(MIGRATION_FLAG_KEY, {
         migratedAt: new Date().toISOString(),
         workoutCount: data.workouts?.length || 0
       });

       // 6. Keep localStorage backup (don't delete - user decision from CONTEXT)
       localStorage.setItem(BACKUP_KEY, localStorageData);

       // 7. Switch to IndexedDB mode
       enableIndexedDB();

       eventBus.emit(EVENTS.MIGRATION_COMPLETE, {
         hadData: true,
         workoutCount: data.workouts?.length || 0
       });

       return { success: true, hadData: true };

     } catch (error) {
       console.error('Migration failed:', error);
       eventBus.emit(EVENTS.MIGRATION_FAILED, { error: error.message });
       return { success: false, error: error.message };
     }
   }
   ```

5. Implement `retryMigration()`:
   ```
   async function retryMigration() {
     // Clear migration flag to allow retry
     await set(MIGRATION_FLAG_KEY, null);
     return migrateToIndexedDB();
   }
   ```

6. Export: `migrateToIndexedDB`, `retryMigration`

Reference Pattern 4 in 01-RESEARCH.md for verification approach.
  </action>
  <verify>
    - `js/data/migration.js` exists
    - Exports migrateToIndexedDB and retryMigration
    - No syntax errors
  </verify>
  <done>
    - Migration module reads localStorage, writes to IndexedDB, verifies integrity
    - Emits MIGRATION_STARTED, MIGRATION_COMPLETE, or MIGRATION_FAILED events
    - Keeps localStorage backup after successful migration
  </done>
</task>

<task type="auto">
  <name>Task 2: Refactor data.js to use async storage</name>
  <files>
    - js/data.js
  </files>
  <action>
1. Add imports at top of data.js:
   ```javascript
   import { storageGet, storageSet, STORAGE_KEY } from './core/storage.js';
   ```

2. Convert `loadData()` to async:
   ```javascript
   export async function loadData() {
     try {
       const data = await storageGet(STORAGE_KEY);
       if (data) {
         // Ensure required fields exist (same validation as before)
         if (!data.exerciseLibrary) {
           data.exerciseLibrary = [...DEFAULT_EXERCISES];
         }
         if (!data.workouts) {
           data.workouts = [];
         }
         if (!data.workoutTemplates) {
           data.workoutTemplates = [...DEFAULT_WORKOUT_TEMPLATES];
         }
         return data;
       }
     } catch (e) {
       console.error('Error loading data:', e);
     }
     return getDefaultData();
   }
   ```

3. Convert `saveData()` to async:
   ```javascript
   export async function saveData(data) {
     try {
       await storageSet(STORAGE_KEY, data);
     } catch (e) {
       console.error('Error saving data:', e);
     }
   }
   ```

4. Update all functions that call saveData to be async and await saveData:
   - `saveWorkout()` - make async, add await saveData(data)
   - `addExerciseToWorkout()` - make async, add await
   - `removeExerciseFromWorkout()` - make async, add await
   - `addCustomExercise()` - make async, add await
   - `removeExerciseFromLibrary()` - make async, add await
   - `addWorkoutTemplate()` - make async, add await
   - `updateWorkoutTemplate()` - make async, add await
   - `deleteWorkoutTemplate()` - make async, add await
   - `applyWorkoutTemplate()` - make async, add await
   - `saveWorkoutAsTemplate()` - make async, add await

5. Remove the local STORAGE_KEY constant (now imported from storage.js).

6. Keep DEFAULT_EXERCISES, DEFAULT_WORKOUT_TEMPLATES, and getDefaultData() unchanged.

Note: Do NOT remove the localStorage import statement or the old code completely - the storage abstraction handles the actual storage backend based on mode. The sync/async behavior is now async throughout.
  </action>
  <verify>
    - data.js imports from './core/storage.js'
    - loadData and saveData are async functions
    - All functions calling saveData are async and use await
    - No syntax errors
  </verify>
  <done>
    - data.js uses async storage abstraction
    - All data operations properly await storage calls
    - Code is ready to work with either localStorage or IndexedDB backend
  </done>
</task>

</tasks>

<verification>
After both tasks complete:
1. `js/data/migration.js` exists with migrateToIndexedDB export
2. `js/data.js` has async loadData/saveData
3. No syntax errors when importing modules
4. Manual test: In browser console, can import and call migrateToIndexedDB()
</verification>

<success_criteria>
- Migration module can migrate data from localStorage to IndexedDB
- Migration verifies data integrity before marking complete
- Migration emits events at each stage
- data.js is fully async and uses storage abstraction
- localStorage backup is preserved after migration
</success_criteria>

<output>
After completion, create `.planning/phases/01-technical-foundation/01-02-SUMMARY.md`
</output>
